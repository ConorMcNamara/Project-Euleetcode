import numpy as np
from math import sqrt
from itertools import compress
from functools import reduce


def problem_1(n=1000, how='numpy'):
    """
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
    The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below n.

    Parameters
    ----------
    n: int, n > 0
         The highest maximum value we want to find all multiples of 3 or 5
    how: str, default is numpy
        Whether we wish to use numpy or list comprehension to solve the problem

    Returns
    -------
    The sum of all multiple of 3 or 5 below n
    """
    if not isinstance(n, int):
        raise ValueError("Value must be in integer format")
    if n < 3:
        raise ValueError("Value must be higher than 3")
    if how.casefold() == 'numpy':
        x = np.arange(1, n)
        viable_x = x[np.where((x % 3 == 0) | (x % 5 == 0))[0]]
    else:
        viable_x = [i for i in range(1, n) if (i % 3 == 0) | (i % 5 == 0)]
    return np.sum(viable_x)


def problem_2(max_val=40000000, how='list'):
    """
    Each new term in the Fibonacci sequence is generated by adding the previous two terms.
    By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed n,
    find the sum of the even-valued terms.

    Parameters
    ----------
    max_val: int, default is 4000000
        The maximum fibonacci number in our sequence
    how: str, default is list
        Whether we wish to use list comprehension or generators for our values

    Returns
    --------
    The sum of all even fibonacci numbers below max
    """
    if not isinstance(max_val, int):
        raise ValueError("Value must be in integer format")
    if max_val < 2:
        raise ValueError("Maximum fibonacci number must be greater or equal to 2")
    if how.casefold() == 'list':
        def _create_fib(max_val=max_val):
            fib_array = [0, 1]
            while True:
                index = fib_array[-1] + fib_array[-2]
                if index > max_val:
                    break
                fib_array.append(index)
            return fib_array

        max_array = _create_fib(max_val)
        return np.sum(list(filter(lambda x: x % 2 == 0, max_array)))
    else:
        def even_fib(max_val=max_val):
            a, b = 0, 1
            while a < max_val:
                if a % 2 == 0:
                    yield a
                a, b = b, a + b
        return sum(even_fib(max_val))


def problem_3(n=600851475143):
    """
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number n?

    Parameters
    ----------
    n: int, default is 600851475143
        The number to find the highest prime factor

    Returns
    -------
    The highest prime factor of n
    """
    def _is_prime(n):
        if n % 2 == 0:
            return False
        for i in range(3, int(sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True

    factors = []
    max_possible = int(sqrt(n))
    if n % 2 == 0:
        factors.append(2)
        n /= 2
    for i in range(3, max_possible + 1, 2):
        if n % i == 0:
            factors.append(i)
            n /= i
            if n == 1:
                break  # Check that all factors found.
    else:
        factors.append(max_possible)

    prime_factors = compress(factors, [_is_prime(factor) for factor in factors])
    return max(prime_factors)


def problem_4(n=3):
    """
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers
    is 9009 = 91 × 99.
    Find the largest palindrome made from the product of two n-digit numbers.

    Parameters
    ----------
    n: int, default is 3
        The number of digits for determining the largest palindrome

    Returns
    -------
    The largest palindrome, given n
    """
    max_digit = '9' * n
    min_digit = '1' + '0' * (n - 1)

    def _find_factors(val):
        step = 2 if val % 2 else 1
        factors = [[len(str(i)), len(str(val // i))] for i in range(1, int(sqrt(val)) + 1, step) if val % i == 0]
        return any([factor == [n, n] for factor in factors])

    for i in range(pow(int(max_digit), 2), pow(int(min_digit), 2) - 1, -1):
        if str(i) == str(i)[::-1]:
            if _find_factors(i):
                return i


def problem_5(n=20):
    """
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to n?

    Parameters
    ----------
    n: int, default is 20
        The maximum range of our divisor

    Returns
    -------
    The smallest positive number that is evenly divisible by the range of n
    """
    if n > 3:
        vals = np.arange(3, n + 1)
    else:
        vals = np.arange(2, n + 1)
    max_val = 999999999999
    print(max_val)
    for i in range(n, max_val, n):
        divisor = i % vals
        if np.all(divisor == 0):
            return i


def problem_6(n=100, how='numpy'):
    """
    The sum of the squares of the first ten natural numbers is,
    1^2+2^2+...+10^2=385
    The square of the sum of the first ten natural numbers is,
    (1+2+...+10)^2=55^2=3025

    Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is
    3025−385=2640.

    Find the difference between the sum of the squares of the first n natural numbers and the square of the sum.

    Parameters
    ----------
    n: int, default is 100
        The maximum number of natural numbers for our algorithm
    how: str, default is numpy
        Whether we are calculating this through numpy, list comprehension or mathematically

    Returns
    -------
    The difference in sum of the squares and the square of the sum.
    """
    if not isinstance(n, int):
        raise ValueError("n must be integer format")
    if how.casefold() == 'numpy':
        sum_squares = np.sum(np.power(np.arange(1, n+1), 2))
        square_sum = np.power(np.sum(np.arange(1, n+1)), 2)
    elif how.casefold() == 'list':
        sum_squares = sum([pow(i, 2) for i in range(1, n+1)])
        square_sum = pow(sum([*range(1, n+1)]), 2)
    else:
        sum_squares = n * (n + 1) / 2
        square_sum = (n * (n + 1) * (2 * n + 1)) / 6
    return square_sum - sum_squares


def problem_7(n=10001):
    """
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the nth prime number?

    Parameters
    ----------
    n: int, default is 10001
        The nth prime number we wish to find

    Returns
    -------
    The nth prime number
    """

    def _find_factors(num):
        step = 2 if num % 2 else 1
        return set(reduce(list.__add__,
                    ([i, num//i] for i in range(1, int(sqrt(num))+1, step) if num % i == 0)))

    if n == 1:
        return 2
    else:
        num_count = 1
        start_val = 3
        while True:
            if len(_find_factors(start_val)) == 2:
                num_count += 1
                if num_count == n:
                    return start_val
            start_val += 2